/**
 * Python WASM module entry point for bundled projects.
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file is generated by build-python-project.py based on enabled C extensions.
 * It registers C extension modules with PyImport_AppendInittab before Python
 * initialization, which is required because WASI doesn't support dlopen.
 *
 * The bundle.h header (generated during build) contains:
 * - BUNDLE_DATA: The zip file as a byte array
 * - BUNDLE_SIZE: Size of the bundle in bytes
 * - ENTRY_MODULE: Name of the Python module to run
 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdbool.h>
#include <stdio.h>
#include <sys/stat.h>
#include <errno.h>

// Generated during build - contains embedded zip bundle
#include "bundle.h"

// WASM export attribute for process() function
#define WASM_EXPORT __attribute__((visibility("default"))) \
                    __attribute__((export_name("process")))

// ===== C EXTENSION DECLARATIONS (AUTO-GENERATED) =====
// {{EXTERN_DECLARATIONS}}

// Static flag to track whether Python has been initialized
// This ensures Python is initialized only once, and the interpreter
// persists across multiple process() calls, allowing Python global
// variables to maintain state.
static bool python_initialized = false;

// Write embedded bundle to filesystem
static int extract_bundle(void) {
    // Create /app directory first
    if (mkdir("/app", 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Failed to create /app directory\n");
        return 1;
    }

    FILE* f = fopen("/app/modules.zip", "wb");
    if (!f) {
        fprintf(stderr, "Failed to create /app/modules.zip\n");
        return 1;
    }

    size_t written = fwrite(BUNDLE_DATA, 1, BUNDLE_SIZE, f);
    fclose(f);

    if (written != BUNDLE_SIZE) {
        fprintf(stderr, "Failed to write bundle: wrote %zu of %zu bytes\n",
                written, (size_t)BUNDLE_SIZE);
        return 1;
    }

    return 0;
}

// ===== C EXTENSION REGISTRATION (AUTO-GENERATED) =====
static int register_extensions(void) {
// {{REGISTER_EXTENSIONS}}
    return 0;
}

// Initialize Python interpreter (called once on first process() call)
static int initialize_python(void) {
    // Extract bundle to filesystem first
    if (extract_bundle() != 0) {
        return 1;
    }

    // Register C extensions BEFORE Py_PreInitialize
    // This is required because WASI doesn't support dlopen
    if (register_extensions() != 0) {
        return 1;
    }

    // Pre-configure Python to use UTF-8 mode
    PyPreConfig preconfig;
    PyPreConfig_InitIsolatedConfig(&preconfig);
    preconfig.utf8_mode = 1;

    PyStatus status = Py_PreInitialize(&preconfig);
    if (PyStatus_Exception(status)) {
        fprintf(stderr, "Failed to pre-initialize Python\n");
        return 1;
    }

    // Initialize Python
    Py_Initialize();

    if (!Py_IsInitialized()) {
        fprintf(stderr, "Failed to initialize Python\n");
        return 1;
    }

    // Add bundle to sys.path
    if (PyRun_SimpleString("import sys; sys.path.insert(0, '/app/modules.zip')") != 0) {
        fprintf(stderr, "Failed to add bundle to sys.path\n");
        return 1;
    }

    python_initialized = true;
    return 0;
}

// Main entry point called by WADUP
WASM_EXPORT
int process(void) {
    // Initialize Python on first call only
    if (!python_initialized) {
        if (initialize_python() != 0) {
            return 1;
        }
    }

    // Build command to run entry module
    // Call main() if it exists, otherwise just import the module
    char cmd[512];
    snprintf(cmd, sizeof(cmd),
        "import %s as _m; _m.main() if hasattr(_m, 'main') else None",
        ENTRY_MODULE);

    // Execute the entry module
    if (PyRun_SimpleString(cmd) != 0) {
        PyErr_Print();
        return 1;
    }

    // NOTE: We do NOT call Py_FinalizeEx() here!
    // The interpreter stays alive across multiple process() calls,
    // allowing Python global variables to persist between files.

    return 0;
}
